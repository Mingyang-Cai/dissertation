#SMC FCS for quadratic case
rm(list=ls())
library(mice, warn.conflicts = FALSE)
library(miceadds)
library(MASS)
library(smcfcs)
library(sn)

#Since it takes much time to do the simulation for SMC-FCS, 
#we showed the code for the case x is standard normal distribution 
#and the missingness mechanism is MCAR.
#For other scenarios, we showed how to adjust the code of complete data generation and amputation.


#For LOCATION AT 0: 
#NORM:        x <- rnorm(sample.size, mean = 0, sd = 1)
#             epsilon <- rnorm(sample.size, mean = 0, sd = 1)
#SKE-NORM     x <- rsn(sample.size, xi = 0, omega = 1, alpha = 6)
#             epsilon <- rnorm(sample.size, mean = 0, sd = 1.17)
#MIXTURE-NORM P <- rbinom(sample.size, 1, 0.5)
#             x <- P * rnorm(sample.size, mean = -0.875, sd = sqrt(0.234)) + (1 - P) * rnorm(sample.size, mean = 0.875, sd = sqrt(0.234))
#             epsilon <- rnorm(sample.size, mean = 0, sd = 0.79)

#For LOCATION AT 2: 
#NORM:        x <- rnorm(sample.size, mean = 2, sd = 1)
#             epsilon <- rnorm(sample.size, mean = 0, sd = 3.5)
#SKE-NORM     x <- rsn(sample.size, xi = 2, omega = 1, alpha = -3)
#             epsilon <- rnorm(sample.size, mean = 0, sd = 1.2)
#MIXTURE-NORM P <- rbinom(sample.size, 1, 0.5)
#             x <- P * rnorm(sample.size, mean = 1.125, sd = sqrt(0.234)) + (1 - P) * rnorm(sample.size, mean = 2.875, sd = sqrt(0.234))
#             epsilon <- rnorm(sample.size, mean = 0, sd = 2.94)

#ALL OUTCOME Y ARE GENERATED BY  y <- x + x^2 + epsilon




set.seed(123)

sample.size <- 100
missingness <- 0.3 #percentage Y incomplete
simulations <- 1000

#prepare output object
coefficient.OUT <- list()

#start simulation
pb <- txtProgressBar(min = 0, max = simulations, style = 3)
for (i in 1:simulations){
  # Generate data
  x <- rnorm(sample.size, mean = 0, sd = 1)
  epsilon <- rnorm(sample.size, mean = 0, sd = 1)
  y <- x + x^2 + epsilon
  complete.data <- cbind(y, x, x^2)
  
  
  # Generate missings in X (ampute)
  incomplete.data <- ampute(data = complete.data, prop = missingness, mech = "MCAR", patterns = c(1, 0, 0))$amp  #MCAR
  #For MARleft, MARmid, MARtail and MARright use the following function with according choices for argument "type" : c('LEFT', 'MID', 'TAIL', 'RIGHT')
  #incomplete.data <- ampute(data=complete.data, prop=missingness, mech = "MAR", type = 'LEFT', patterns = c(1, 0, 0), weights = c(1, 0, 0))$amp
  
  imp <- smcfcs(incomplete.data, smtype = "lm", smformula = "Y~X+XX", method = c("", "norm", "X^2"), rjlimit= 10000)
  
  summary.OUT <- list()
  for (j in 1:5) {
    summary.OUT[[j]] <- summary(lm(imp$impDatasets[[j]]$Y~imp$impDatasets[[j]]$X+imp$impDatasets[[j]]$XX))
  }
  coefficient.OUT[[i]] <- summary.OUT
  setTxtProgressBar(pb, i)
}
close(pb)

# Evaluate the coverage rate
evaluate.sims <- function(sims, truth = 1){
  POOL <- list()
  pb <- txtProgressBar(min = 0, max = simulations, style = 3)
  for (i in 1:length(sims)){
    #Extract means and variances
    Q            <- c(coefficient.OUT[[i]][[1]]$coefficients[2,1], coefficient.OUT[[i]][[2]]$coefficients[2,1],
                      coefficient.OUT[[i]][[3]]$coefficients[2,1], coefficient.OUT[[i]][[4]]$coefficients[2,1],
                      coefficient.OUT[[i]][[5]]$coefficients[2,1])
    
    U            <- c((coefficient.OUT[[i]][[1]]$coefficients[2,2])^2, (coefficient.OUT[[i]][[2]]$coefficients[2,2])^2,
                      (coefficient.OUT[[i]][[3]]$coefficients[2,2])^2, (coefficient.OUT[[i]][[4]]$coefficients[2,2])^2, 
                      (coefficient.OUT[[i]][[5]]$coefficients[2,2])^2)
    #Pool the regular way
    pool         <- mice::pool.scalar(Q, U, n = 1000) # A really large number
    pool$lower   <- pool$qbar - qt(0.975, pool$df) * sqrt(pool$t)
    pool$upper   <- pool$qbar + qt(0.975, pool$df) * sqrt(pool$t)
    pool$true <- 1
    pool$bias <- pool$qbar - pool$true
    pool$cov <- pool$lower < pool$true & pool$true < pool$upper
    pool$ciw <- pool$upper - pool$lower
    POOL[[i]]     <- unlist(pool)
    setTxtProgressBar(pb, i)
  }
  return(POOL)
  close(pb)
}
EVAL.B1 <- evaluate.sims(coefficient.OUT)
# Summarize
AVG.EVAL.B1 <- Reduce("+", EVAL.B1) / length(EVAL.B1)
round(AVG.EVAL.B1, 2)

# Evaluate the coverage rate
evaluate.sims <- function(sims, truth = 1){
  POOL <- list()
  pb <- txtProgressBar(min = 0, max = simulations, style = 3)
  for (i in 1:length(sims)){
    #Extract means and variances
    Q            <- c(coefficient.OUT[[i]][[1]]$coefficients[3,1], coefficient.OUT[[i]][[2]]$coefficients[3,1],
                      coefficient.OUT[[i]][[3]]$coefficients[3,1], coefficient.OUT[[i]][[4]]$coefficients[3,1],
                      coefficient.OUT[[i]][[5]]$coefficients[3,1])
    
    U            <- c((coefficient.OUT[[i]][[1]]$coefficients[3,2])^2, (coefficient.OUT[[i]][[2]]$coefficients[3,2])^2,
                      (coefficient.OUT[[i]][[3]]$coefficients[3,2])^2, (coefficient.OUT[[i]][[4]]$coefficients[3,2])^2, 
                      (coefficient.OUT[[i]][[5]]$coefficients[3,2])^2)
    #Pool the regular way
    pool         <- mice::pool.scalar(Q, U, n = 1000) # A really large number
    pool$lower   <- pool$qbar - qt(0.975, pool$df) * sqrt(pool$t)
    pool$upper   <- pool$qbar + qt(0.975, pool$df) * sqrt(pool$t)
    pool$true <- 1
    pool$bias <- pool$qbar - pool$true
    pool$cov <- pool$lower < pool$true & pool$true < pool$upper
    pool$ciw <- pool$upper - pool$lower
    POOL[[i]]     <- unlist(pool)
    setTxtProgressBar(pb, i)
  }
  return(POOL)
  close(pb)
}
EVAL.B2 <- evaluate.sims(coefficient.OUT)
# Summarize
AVG.EVAL.B2 <- Reduce("+", EVAL.B2) / length(EVAL.B2)
round(AVG.EVAL.B2, 2)






